#!/bin/bash

#          ,.,
#         MMMM_    ,..,
#           "_ "__"UVER          ,.......,,
#    ,..., __." --"    ,.,     _-"UFACILITY
#    "UCORE___ "_._   MMM"_."" _ """"""""""
#    """""    "" , \_.   "_. ."
#           ,., _"__ \__./ ."
#       ULAUNCHER_"  "_    ./
#           ''''      (    )
#    ._______________.-'____"---._.
#     \          UMEDIA          /
#      \________________________/
#      (_)                    (_)
#
# Should be called after ./env as a separated call inside of ~./bashrc. Therefore,
# letting users to be able to override locally any environment value that was previously
# set during ./env execution.

# checking if it's being triggered under upipe domain
if [ -z "$UPIPE_ROOT" ]; then
  echo "UPIPE_ROOT IS NOT SET, ARE YOU UNDER UPIPE ENV ?" >&2
else
  # current dir
  dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

  # by default the version of versioned depedencies is driven by their
  # respective version environment. However when ubash is set to either "stable" or
  # "beta" this value can be used to drive the defaults of the versioned depedencies
  # that have not been defined yet. Also, if the target of versioned depedencies is a
  # symlink it is going to extract the target and assign to the version variable.
  # This is necessary to ensure the environment is going to be the same, no matter
  # what. Therefore, any changes in symlinks aka "stable" or "beta" is not goint
  # to affect the current environment.
  versionedNames="UFACILITY UVER UCORE ULAUNCHER"
  autoAssignTypes="stable beta alpha"
  bashVersionType=$UBASH_VERSION
  for versioned in $versionedNames
  do
    versionedRootName="${versioned}_ROOT"
    versionedRootValue="${!versionedRootName}"
    versionedVersionName="${versioned}_VERSION"
    versionedVersionValue="${!versionedVersionName}"

    # when bash version is assigned with stable or beta and the versioned does not
    # have a value assigned to it.
    if [[ -z "$versionedVersionValue" && "$autoAssignTypes" == *"$bashVersionType"* ]]; then
      versionedVersionValue=$bashVersionType
    fi

    # showing an error when versioned is not defined at this point
    if [ -z "$versionedVersionValue" ]; then
      echo "uver error: $versioned version is not defined (\$$versionedVersionName)!" >&2
      continue
    fi

    # additionally, if versioned target is a symlink, lets assign the target rather than
    # keeping a symlink that may change...
    versionedTarget="$versionedRootValue/$versionedVersionValue"
    if [[ -L "$versionedTarget" && -d "$versionedTarget" ]]; then
      versionedVersionValue=$(readlink "$versionedTarget")
    fi

    # exporting the final version of the versioned variable
    export "$versionedVersionName"=$versionedVersionValue
  done

  # running auxiliary envs after the versioned envs have been resolved and
  # before the initialization of the versioned scripts (since the scripts
  # may use them)
  source $dir/aux

  # running versioned initialization
  for versioned in $versionedNames
  do
    versionedRootName="${versioned}_ROOT"
    versionedRootValue="${!versionedRootName}"
    versionedVersionName="${versioned}_VERSION"
    versionedVersionValue="${!versionedVersionName}"

    # initializing versioned
    versionedLocation="$versionedRootValue/$versionedVersionValue"
    if [ -d "$versionedLocation" ]; then

      # sourcing init file when necessary
      initFile="$versionedLocation/init"
      if [ -f "$initFile" ]; then
        source $versionedLocation/init
      fi

      # otherwise something went wrong...
    else
      echo "uver error: $versioned could not be localized ($versionedLocation)!" >&2
    fi
  done
fi
