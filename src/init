#!/bin/bash

#          ,.,
#         UEVENTS_    ,..,
#           "_ "__"UVER          ,.......,,
#    ,..., __." --"    ,.,     _-"UFACILITY
#    "UCORE___ "_._   MMM"_."" _ """"""""""
#    """""    "" , \_.   "_. ."
#           ,., _"__ \__./ ."
#       ULAUNCHER_"  "_    ./
#           ''''      (    )
#    ._______________.-'____"---._.
#     \          UMEDIA          /
#      \________________________/
#      (_)                    (_)
#
# ./init should be sourced after ./env in ~./bashrc or a similar login script. 
# This allows users to override any Upipe environment vars established by 
# ./env, thereby customizing their running environment. Users should export vars
# after ./env is sourced, but before ./init is sourced by their login scripts. 
# The Upipe vars that are set in advance with ./env indlude:
# UPIPE_PATH, UCORE_VERSION, UFACILITY_VERSION, UVER_VERSION, ULAUNCHER_VERSION
# UEVENTS_VERSION, UVER_VERSIONS_DIR, ULAUNCHER_CONFIG_DIR, UFACIITY_NAME


# checking if it's being triggered under upipe domain
if [ -z "$UPIPE_ROOT" ]; then
  echo "UPIPE_ROOT IS NOT DEFINED, ARE YOU UNDER UPIPE ENV ?" >&2
elif [ -z "$UPIPE_PATH" ]; then
  echo "UPIPE_PATH IS NOT DEFINED, DID YOU SOURCE 'ubash/env' file ?" >&2
else
  # current dir
  dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

  # development enviromnent support:
  # First we give users an alias command "devenv" that launches a subshell where 
  # ISDEVENV=1 and we re-source .bashrc (and this file), resulting in a prompt cue
  # like "[DEV][...]$" and prepending UPIPE_DEV_ROOT to UPIPE_PATH.
  # The construct "bash init-file ..." allows us to remain in the subshell until exit.
  alias devenv='bash --init-file <(echo "export ISDEVENV=1 && source $HOME/.bashrc")'

  # This section normally only executes when a user runs 'devenv'. The default 
  # value for UPIPE_PATH is previously set by ./env, but the user may have 
  # overridden this by exporting a custom UPIPE_PATH. Therefore, when a user
  # runs 'devenv' we use whatever is currently for UPIPE_PATH and prepend the
  # location of UPIPE_DEV_ROOT to UPIPE_PATH. Since 'devenv' re-sources this file 
  # via ~/.bashrc, we can keep any Upipe environment tweaks the user has done as 
  # well as prepending UPIPE_DEV_ROOT and modifying their shell prompt.
  if [[ "$ISDEVENV" == "1" ]]; then
    export UPIPE_PATH="$UPIPE_DEV_ROOT:$UPIPE_PATH"
    # adding [DEV] to the shell prompt as a reminder that we are in dev environment
    export PS1="[DEV]$PS1"
  fi

  # Adding UBASH_BIN_PATH to the environment and prepending it to PATH.
  ubashBinPath+="$dir/bin"
  if ! [ "$UBASH_BIN_PATH" == "$ubashBinPath" ]; then
    export UBASH_BIN_PATH=$ubashBinPath
    export PATH="$UBASH_BIN_PATH:$PATH"
  fi

  # by default the version of versioned depedencies is driven by their
  # respective version environment. However when ubash is set to "stable", "beta" or
  # "alpha" this value can be used to drive the defaults of the versioned depedencies
  # that have not been defined yet. Also, if the target of versioned depedencies is a
  # symlink it is going to extract the target and assign to the version variable.
  # This is necessary to ensure the environment is going to be the same, no matter
  # what. Therefore, any changes in symlinks aka "stable" or "beta" is not going
  # to affect the current environment.
  autoAssignTypes="stable beta alpha"
  bashVersionType=$UBASH_VERSION
  for versioned in $UBASH_VERSIONED_NAMES "UBASH";
  do
    versionedVersionName="${versioned}_VERSION"
    versionedVersionValue="${!versionedVersionName}"

    # when bash version is assigned with stable, beta, alpha and the versioned does not
    # have a value assigned to it.
    if [[ -z "$versionedVersionValue" && "$autoAssignTypes" == *"$bashVersionType"* ]]; then
      versionedVersionValue=$bashVersionType
    fi

    # showing an error when versioned is not defined at this point
    if [ -z "$versionedVersionValue" ]; then
      echo "ubash error: $versioned version is not defined (\$$versionedVersionName)!" >&2
      continue
    fi

    # we also want to resolve the version of ubash itself, but we don't need
    # to look for it
    if [[ "$versioned" == "UBASH" ]]; then
      versionedTarget="$dir"

    # looking for versioned targets
    else
      # looking for the versioned first under the upipe root (root repository), if it
      # is not there yet then try to find it using locres (in case it's a module that
      # is still under development)
      versionedTarget="$UPIPE_ROOT/${versioned~~}/$versionedVersionValue"

      if ! [[ -d "$versionedTarget" ]]; then
        # in case the module is not release yet under UPIPE_ROOT, make sure you
        # have the symlinks "alpha, beta and stable" for the dev module.
        versionedTarget="$( locres ${versioned~~}/$versionedVersionValue )"
      fi
    fi

    # additionally, if versioned target is a symlink, lets assign the target
    # rather than keeping a symlink that may change...
    # The target symlink can also be another symlink aka alpha pointing
    # to beta and beta pointing to stable, handling that behaviour
    for symlinkPointingTo in $autoAssignTypes;
    do
      if [[ -L "$versionedTarget" && -d "$versionedTarget" ]]; then
        versionedVersionValue=$(readlink "$versionedTarget")
        versionedVersionValue=$(basename "$versionedVersionValue")
      fi

      # when found version is not a symlink, stopping it
      versionedTarget="$(dirname $versionedTarget)/$versionedVersionValue"
      if ! [[ -L "$versionedTarget" && -d "$versionedTarget" ]]; then
        break
      fi
    done

    # exporting the final version of the versioned variable
    export "$versionedVersionName"=$versionedVersionValue
  done

  # running auxiliary envs after the versioned envs have been resolved and
  # before the initialization of the versioned scripts (since the scripts
  # may use them)
  source $dir/aux

  # running versioned initialization
  for versioned in $UBASH_VERSIONED_NAMES
  do
    versionedVersionName="${versioned}_VERSION"
    versionedVersionValue="${!versionedVersionName}"

    # initializing versioned
    versionedLocation="$( locres ${versioned~~}/$versionedVersionValue )"
    if [ -d "$versionedLocation" ]; then

      # sourcing init file when necessary
      initFile="$versionedLocation/init"
      if [ -f "$initFile" ]; then
        source $versionedLocation/init
      fi

      # otherwise something went wrong...
    else
      echo "ubash error: $versioned could not be localized ($versionedLocation)!" >&2
    fi
  done
fi
